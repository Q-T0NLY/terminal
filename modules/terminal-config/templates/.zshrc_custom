#!/bin/zsh
# ============================================================================
# CLEAN SLATE INITIALIZATION - CUSTOM CONFIGURATION
# Advanced System Scanner, Classifier & Factory Reset Engine
# macOS Big Sur (Intel) - Production Grade
# Version: 3.0
# ============================================================================

# ============================================
# CLEAN SLATE GLOBAL CONFIGURATION
# ============================================

# Core directories
export CLEANSLATE_HOME="${HOME}/.cleanslate"
export CLEANSLATE_DATA="${CLEANSLATE_HOME}/data"
export CLEANSLATE_LOGS="${CLEANSLATE_HOME}/logs"
export CLEANSLATE_REPORTS="${CLEANSLATE_HOME}/reports"
export CLEANSLATE_TRASH="${CLEANSLATE_HOME}/trash"
export CLEANSLATE_CONFIG="${CLEANSLATE_HOME}/config"
export CLEANSLATE_CACHE="${CLEANSLATE_HOME}/cache"

# Create directory structure
mkdir -p "$CLEANSLATE_DATA" "$CLEANSLATE_LOGS" "$CLEANSLATE_REPORTS" "$CLEANSLATE_TRASH" "$CLEANSLATE_CONFIG" "$CLEANSLATE_CACHE"

# Configuration files
export CLEANSLATE_SCAN_DB="${CLEANSLATE_DATA}/scan_database.json"
export CLEANSLATE_CLASSIFICATION_DB="${CLEANSLATE_DATA}/classifications.json"
export CLEANSLATE_SIGNATURE_DB="${CLEANSLATE_DATA}/signatures.db"
export CLEANSLATE_CONFIG_FILE="${CLEANSLATE_CONFIG}/cleanslate.conf"

# Log files
export CLEANSLATE_MAIN_LOG="${CLEANSLATE_LOGS}/cleanslate_$(date +%Y%m).log"
export CLEANSLATE_SCAN_LOG="${CLEANSLATE_LOGS}/scan_$(date +%Y%m).log"
export CLEANSLATE_CLEANUP_LOG="${CLEANSLATE_LOGS}/cleanup_$(date +%Y%m).log"

# Colors for output
export CLEANSLATE_COLOR_RESET='\033[0m'
export CLEANSLATE_COLOR_RED='\033[0;31m'
export CLEANSLATE_COLOR_GREEN='\033[0;32m'
export CLEANSLATE_COLOR_YELLOW='\033[0;33m'
export CLEANSLATE_COLOR_BLUE='\033[0;34m'
export CLEANSLATE_COLOR_MAGENTA='\033[0;35m'
export CLEANSLATE_COLOR_CYAN='\033[0;36m'
export CLEANSLATE_COLOR_WHITE='\033[0;37m'
export CLEANSLATE_COLOR_BOLD='\033[1m'

# ============================================
# LOGGING SYSTEM
# ============================================

cleanslate_log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_entry="[${timestamp}] [${level}] ${message}"
    
    # Console output with color
    case "$level" in
        INFO)
            echo -e "${CLEANSLATE_COLOR_BLUE}â„¹ ${CLEANSLATE_COLOR_RESET}${message}"
            ;;
        SUCCESS)
            echo -e "${CLEANSLATE_COLOR_GREEN}âœ“ ${CLEANSLATE_COLOR_RESET}${message}"
            ;;
        WARNING)
            echo -e "${CLEANSLATE_COLOR_YELLOW}âš  ${CLEANSLATE_COLOR_RESET}${message}"
            ;;
        ERROR)
            echo -e "${CLEANSLATE_COLOR_RED}âœ— ${CLEANSLATE_COLOR_RESET}${message}"
            ;;
        CRITICAL)
            echo -e "${CLEANSLATE_COLOR_RED}${CLEANSLATE_COLOR_BOLD}ğŸ’¥ ${message}${CLEANSLATE_COLOR_RESET}"
            ;;
    esac
    
    # File logging
    echo "$log_entry" >> "$CLEANSLATE_MAIN_LOG"
}

# ============================================
# UTILITY FUNCTIONS
# ============================================

print_header() {
    local title="$1"
    local width=70
    
    echo ""
    echo "$(printf 'â•%.0s' {1..$width})"
    echo "  $title"
    echo "$(printf 'â•%.0s' {1..$width})"
    echo ""
}

print_separator() {
    echo "$(printf 'â”€%.0s' {1..70})"
}

confirm_action() {
    local prompt="$1"
    local default="${2:-y}"
    
    if [[ "$default" == "y" ]]; then
        read -q "REPLY?${prompt} [Y/n]: "
    else
        read -q "REPLY?${prompt} [y/N]: "
    fi
    
    echo ""
    [[ "$REPLY" == "y" ]]
}

pause() {
    read -k1 "?Press any key to continue..."
    echo ""
}

format_bytes() {
    local bytes=$1
    if (( bytes >= 1073741824 )); then
        echo "$(echo "scale=2; $bytes/1073741824" | bc) GB"
    elif (( bytes >= 1048576 )); then
        echo "$(echo "scale=2; $bytes/1048576" | bc) MB"
    elif (( bytes >= 1024 )); then
        echo "$(echo "scale=2; $bytes/1024" | bc) KB"
    else
        echo "$bytes B"
    fi
}

# ============================================
# ENHANCED METADATA COLLECTION
# ============================================

collect_file_metadata() {
    local file="$1"
    local stats=()
    
    # Check if file exists
    if [[ ! -e "$file" ]]; then
        echo '{"error":"file_not_found"}'
        return 1
    fi
    
    # ===== ENHANCED UNIX METADATA =====
    # Permissions with full detail
    local perms=$(stat -f "%Sp" "$file" 2>/dev/null || echo "?????????")
    local perms_octal=$(stat -f "%p" "$file" 2>/dev/null || echo "0")
    stats+=("permissions_octal=$(printf '%04o' $perms_octal)")
    stats+=("permissions_symbolic=$perms")
    
    # Special permission flags
    stats+=("permissions_suid=$([[ "$perms" =~ ^...s ]] && echo "true" || echo "false")")
    stats+=("permissions_sgid=$([[ "$perms" =~ ^......s ]] && echo "true" || echo "false")")
    stats+=("permissions_sticky=$([[ "$perms" =~ ^.........t ]] && echo "true" || echo "false")")
    
    # Enhanced timestamps with ISO format
    local created=$(stat -f "%B" "$file" 2>/dev/null || echo "0")
    local modified=$(stat -f "%m" "$file" 2>/dev/null || echo "0")
    local accessed=$(stat -f "%a" "$file" 2>/dev/null || echo "0")
    stats+=("created_epoch=$created")
    stats+=("modified_epoch=$modified")
    stats+=("accessed_epoch=$accessed")
    stats+=("created_iso=$(date -r "$created" '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || echo '')")
    stats+=("modified_iso=$(date -r "$modified" '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || echo '')")
    
    # Enhanced ownership with IDs
    stats+=("owner_name=$(stat -f "%Su" "$file" 2>/dev/null || echo 'unknown')")
    stats+=("owner_id=$(stat -f "%u" "$file" 2>/dev/null || echo '0')")
    stats+=("group_name=$(stat -f "%Sg" "$file" 2>/dev/null || echo 'unknown')")
    stats+=("group_id=$(stat -f "%g" "$file" 2>/dev/null || echo '0')")
    
    # File size with human readable
    local size=$(stat -f "%z" "$file" 2>/dev/null || echo 0)
    stats+=("size_bytes=$size")
    stats+=("size_human=$(format_bytes $size)")
    
    # Inode and link information
    stats+=("inode=$(stat -f "%i" "$file" 2>/dev/null || echo '0')")
    stats+=("links=$(stat -f "%l" "$file" 2>/dev/null || echo '0')")
    
    # ===== ENHANCED macOS-SPECIFIC ATTRIBUTES =====
    # Extended Attributes (detailed)
    if command -v xattr &> /dev/null; then
        local xattrs=($(xattr "$file" 2>/dev/null || true))
        stats+=("xattr_count=${#xattrs[@]}")
        
        if [[ ${#xattrs[@]} -gt 0 ]]; then
            for attr in "${xattrs[@]}"; do
                case "$attr" in
                    "com.apple.quarantine")
                        local quarantine=$(xattr -p com.apple.quarantine "$file" 2>/dev/null || echo "")
                        stats+=("xattr_quarantine=${quarantine// /_}")
                        ;;
                    "com.apple.metadata:_kMDItemUserTags")
                        stats+=("xattr_has_tags=true")
                        ;;
                    "com.apple.TextEncoding")
                        local encoding=$(xattr -p com.apple.TextEncoding "$file" 2>/dev/null || echo "")
                        stats+=("xattr_textencoding=${encoding// /_}")
                        ;;
                esac
            done
        fi
    fi
    
    # Enhanced Code Signature Analysis
    if command -v codesign &> /dev/null; then
        if codesign -v "$file" &>/dev/null; then
            stats+=("signature=valid")
            
            # Get detailed signature info
            local sign_info=$(codesign -d -v "$file" 2>&1 || echo "")
            
            if echo "$sign_info" | grep -q "Authority=Apple"; then
                stats+=("signature_signed=apple")
            elif echo "$sign_info" | grep -q "Authority=Developer ID"; then
                stats+=("signature_signed=developer")
            elif echo "$sign_info" | grep -q "Authority="; then
                stats+=("signature_signed=other")
            else
                stats+=("signature_signed=unknown")
            fi
            
            # Check if signature is hardened
            stats+=("signature_hardened=$(echo "$sign_info" | grep -q "Runtime Version" && echo "true" || echo "false")")
            
            # Check if signature is ad-hoc
            stats+=("signature_adhoc=$(echo "$sign_info" | grep -q "adhoc" && echo "true" || echo "false")")
        else
            stats+=("signature=invalid")
        fi
    fi
    
    # ACL Analysis
    local acl_count=$(ls -le "$file" 2>/dev/null | tail -n +2 | wc -l | tr -d ' ')
    stats+=("acl_count=$acl_count")
    
    # Spotlight Comments
    if command -v mdls &> /dev/null && [[ -f "$file" ]]; then
        local comment=$(mdls -name kMDItemFinderComment "$file" 2>/dev/null | cut -d= -f2 | tr -d '"' | xargs)
        if [[ "$comment" != "(null)" ]] && [[ -n "$comment" ]]; then
            stats+=("spotlight_comment=${comment// /_}")
        fi
    fi
    
    # ===== ENHANCED FILE TYPE IDENTIFICATION =====
    if [[ -d "$file" ]]; then
        stats+=("type=directory")
        
        # Check if it's a bundle
        if [[ "$file" =~ \.(app|framework|bundle|plugin)$ ]]; then
            local bundle_type=$(basename "$file" | grep -o '\.[^.]*$' | cut -c2-)
            stats+=("bundle_type=$bundle_type")
            
            # Extract bundle info from Info.plist
            if [[ -f "$file/Contents/Info.plist" ]]; then
                local bundle_id=$(defaults read "$file/Contents/Info.plist" CFBundleIdentifier 2>/dev/null || echo "")
                [[ -n "$bundle_id" ]] && stats+=("bundle_id=${bundle_id// /_}")
                
                local bundle_name=$(defaults read "$file/Contents/Info.plist" CFBundleName 2>/dev/null || echo "")
                [[ -n "$bundle_name" ]] && stats+=("bundle_name=${bundle_name// /_}")
                
                local bundle_version=$(defaults read "$file/Contents/Info.plist" CFBundleShortVersionString 2>/dev/null || echo "")
                [[ -n "$bundle_version" ]] && stats+=("bundle_version=${bundle_version// /_}")
            fi
        fi
        
    elif [[ -f "$file" ]]; then
        stats+=("type=file")
        local mime=$(file --mime-type -b "$file" 2>/dev/null || echo "application/octet-stream")
        stats+=("mime=${mime// /_}")
        
        # File type categorization
        case "$mime" in
            text/*)
                stats+=("file_category=text")
                stats+=("line_count=$(wc -l < "$file" 2>/dev/null || echo 0)")
                ;;
            application/x-mach-binary|application/x-executable)
                stats+=("file_category=binary")
                if command -v lipo &> /dev/null && lipo -info "$file" &>/dev/null; then
                    local arch=$(lipo -info "$file" 2>/dev/null | cut -d: -f3 | xargs)
                    stats+=("binary_arch=${arch// /_}")
                fi
                ;;
            application/x-dylib)
                stats+=("file_category=library")
                ;;
            image/*)
                stats+=("file_category=image")
                ;;
            *)
                # Check for shebang
                if head -c 2 "$file" 2>/dev/null | grep -q "^#!"; then
                    stats+=("file_category=script")
                    local interpreter=$(head -n 1 "$file" 2>/dev/null | cut -d' ' -f1 | cut -c3-)
                    stats+=("script_interpreter=${interpreter// /_}")
                fi
                ;;
        esac
        
    elif [[ -L "$file" ]]; then
        stats+=("type=symlink")
        local target=$(readlink "$file" 2>/dev/null || echo "")
        stats+=("target=${target// /_}")
        stats+=("target_exists=$([[ -e "$(readlink -f "$file" 2>/dev/null)" ]] && echo "true" || echo "false")")
        
    elif [[ -p "$file" ]]; then
        stats+=("type=pipe")
    elif [[ -S "$file" ]]; then
        stats+=("type=socket")
    elif [[ -b "$file" ]]; then
        stats+=("type=block_device")
    elif [[ -c "$file" ]]; then
        stats+=("type=character_device")
    fi
    
    # ===== ENHANCED RELATIONSHIP ANALYSIS =====
    # Process dependencies
    if [[ -f "$file" ]] || [[ -d "$file" ]]; then
        local handles=$(lsof "$file" 2>/dev/null | tail -n +2 || echo "")
        local handle_count=$(echo "$handles" | grep -c . || echo "0")
        stats+=("open_handles_count=$handle_count")
        
        if [[ $handle_count -gt 0 ]]; then
            stats+=("is_memory_mapped=$(echo "$handles" | grep -q "mem" && echo "true" || echo "false")")
        fi
    fi
    
    # ===== FILE INTEGRITY CHECKS =====
    # Calculate checksums for important files (< 100MB)
    if [[ -f "$file" ]] && [[ $size -lt 104857600 ]]; then
        local md5=$(md5 -q "$file" 2>/dev/null || echo "")
        local sha256=$(shasum -a 256 "$file" 2>/dev/null | cut -d' ' -f1 || echo "")
        [[ -n "$md5" ]] && stats+=("checksum_md5=$md5")
        [[ -n "$sha256" ]] && stats+=("checksum_sha256=$sha256")
    fi
    
    # Build JSON output
    local json_stats="{"
    local first=true
    for stat in "${stats[@]}"; do
        local key="${stat%%=*}"
        local value="${stat#*=}"
        
        # Escape quotes and special characters for JSON
        value=$(echo "$value" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
        
        if $first; then
            first=false
        else
            json_stats+=","
        fi
        
        json_stats+="\"$key\":\"$value\""
    done
    json_stats+="}"
    
    echo "$json_stats"
}

# ============================================
# ENHANCED CLASSIFICATION ENGINE
# ============================================

classify_file() {
    local path="$1"
    local metadata_json="$2"
    
    # Parse metadata using grep/sed (more portable than jq)
    local signature=$(echo "$metadata_json" | grep -o '"signature":"[^"]*"' | cut -d'"' -f4)
    local signature_signed=$(echo "$metadata_json" | grep -o '"signature_signed":"[^"]*"' | cut -d'"' -f4)
    local owner_name=$(echo "$metadata_json" | grep -o '"owner_name":"[^"]*"' | cut -d'"' -f4)
    local type=$(echo "$metadata_json" | grep -o '"type":"[^"]*"' | cut -d'"' -f4)
    local mime=$(echo "$metadata_json" | grep -o '"mime":"[^"]*"' | cut -d'"' -f4)
    local bundle_type=$(echo "$metadata_json" | grep -o '"bundle_type":"[^"]*"' | cut -d'"' -f4)
    local file_category=$(echo "$metadata_json" | grep -o '"file_category":"[^"]*"' | cut -d'"' -f4)
    
    # Scoring system for classification confidence
    local system_score=0
    local core_score=0
    local app_score=0
    local config_score=0
    local user_score=0
    
    # ===== RULE 1: SYSTEM CRITICAL FILES =====
    if [[ "$path" =~ ^/(System|usr/lib|bin|sbin|private/var/db) ]]; then
        system_score=$((system_score + 100))
    fi
    
    # SIP-protected volume detection
    if [[ "$path" =~ ^/System/Volumes/ ]]; then
        system_score=$((system_score + 100))
    fi
    
    # Kernel extensions and drivers
    if [[ "$path" =~ \.(kext|dylib)$ ]] && [[ "$path" =~ ^/(System|Library/Extensions) ]]; then
        system_score=$((system_score + 80))
    fi
    
    # Apple-signed system binaries
    if [[ "$signature_signed" == "apple" ]] && [[ "$path" =~ ^/(usr|bin|sbin)/ ]]; then
        system_score=$((system_score + 90))
    fi
    
    # ===== RULE 2: CORE OS COMPONENTS =====
    # Apple frameworks and shared components
    if [[ "$path" =~ \.framework$ ]] || [[ "$path" =~ ^/Library/Frameworks/ ]]; then
        core_score=$((core_score + 70))
    fi
    
    # Apple-signed applications in /Applications (Stock apps)
    if [[ "$signature_signed" == "apple" ]] && [[ "$path" =~ ^/Applications/.*\.app$ ]]; then
        core_score=$((core_score + 60))
    fi
    
    # System preference panes
    if [[ "$path" =~ \.prefPane$ ]] && [[ "$path" =~ ^/(System|Library)/PreferencePanes/ ]]; then
        core_score=$((core_score + 65))
    fi
    
    # System daemons and agents
    if [[ "$path" =~ \.plist$ ]] && [[ "$path" =~ ^/(System|Library)/(LaunchDaemons|LaunchAgents)/ ]]; then
        core_score=$((core_score + 75))
    fi
    
    # ===== RULE 3: APPLICATIONS =====
    # GUI application bundles
    if [[ "$bundle_type" == "app" ]] || [[ "$path" =~ \.app$ ]]; then
        app_score=$((app_score + 80))
        
        # Developer-signed apps get higher score
        if [[ "$signature_signed" == "developer" ]]; then
            app_score=$((app_score + 20))
        fi
        
        # Unsigned apps in /Applications
        if [[ "$signature" == "invalid" ]] && [[ "$path" =~ ^/Applications/ ]]; then
            app_score=$((app_score + 40))
        fi
    fi
    
    # Command line tools and utilities
    if [[ "$file_category" == "binary" ]] && [[ "$path" =~ ^/usr/local/(bin|sbin|opt)/ ]]; then
        app_score=$((app_score + 60))
    fi
    
    # Homebrew installations
    if [[ "$path" =~ ^/usr/local/(Cellar|Caskroom|Homebrew)/ ]] || [[ "$path" =~ ^/opt/homebrew/ ]]; then
        app_score=$((app_score + 70))
    fi
    
    # ===== RULE 4: CONFIGURATIONS =====
    # Configuration files by extension
    if [[ "$path" =~ \.(plist|conf|config|cfg|ini|properties|rc|cnf)$ ]]; then
        config_score=$((config_score + 50))
    fi
    
    # Configuration directories
    if [[ "$path" =~ /(Preferences|Configuration|Profiles|Settings)/ ]]; then
        config_score=$((config_score + 60))
    fi
    
    # System configuration locations
    if [[ "$path" =~ ^/(etc|private/etc)/ ]]; then
        config_score=$((config_score + 70))
    fi
    
    # User configuration files
    if [[ "$path" =~ ^"$HOME"/(\.(bash|zsh|git|ssh|vim|tmux).*|Library/Preferences/) ]]; then
        config_score=$((config_score + 40))
    fi
    
    # ===== RULE 5: USER DATA =====
    # User home directory contents
    if [[ "$path" =~ ^"$HOME"/(Downloads|Documents|Desktop|Movies|Music|Pictures|Public)/ ]]; then
        user_score=$((user_score + 90))
    fi
    
    # Temporary files
    if [[ "$path" =~ ^/(private/)?(tmp|var/tmp|var/folders)/ ]]; then
        user_score=$((user_score + 85))
    fi
    
    # User cache files
    if [[ "$path" =~ ^"$HOME"/Library/Caches/ ]]; then
        user_score=$((user_score + 70))
    fi
    
    # User application support
    if [[ "$path" =~ ^"$HOME"/Library/Application\ Support/[^/]+/ ]] && [[ ! "$path" =~ \.app$ ]]; then
        user_score=$((user_score + 60))
    fi
    
    # ===== RULE 6: SPECIAL CASES =====
    # Disk images and installers
    if [[ "$path" =~ \.(dmg|pkg|mpkg|iso)$ ]]; then
        user_score=$((user_score + 80))
    fi
    
    # Archives and compressed files
    if [[ "$path" =~ \.(zip|tar|gz|bz2|xz|7z|rar)$ ]]; then
        user_score=$((user_score + 75))
    fi
    
    # ===== FINAL CLASSIFICATION DECISION =====
    # Find the highest score
    local highest_category="UNKNOWN"
    local highest_score=0
    local second_highest_score=0
    local second_category=""
    
    # System category
    if [[ $system_score -gt $highest_score ]]; then
        second_highest_score=$highest_score
        second_category=$highest_category
        highest_score=$system_score
        highest_category="SYSTEM"
    elif [[ $system_score -gt $second_highest_score ]]; then
        second_highest_score=$system_score
        second_category="SYSTEM"
    fi
    
    # Core category
    if [[ $core_score -gt $highest_score ]]; then
        second_highest_score=$highest_score
        second_category=$highest_category
        highest_score=$core_score
        highest_category="CORE"
    elif [[ $core_score -gt $second_highest_score ]]; then
        second_highest_score=$core_score
        second_category="CORE"
    fi
    
    # Application category
    if [[ $app_score -gt $highest_score ]]; then
        second_highest_score=$highest_score
        second_category=$highest_category
        highest_score=$app_score
        highest_category="APPLICATION"
    elif [[ $app_score -gt $second_highest_score ]]; then
        second_highest_score=$app_score
        second_category="APPLICATION"
    fi
    
    # Configuration category
    if [[ $config_score -gt $highest_score ]]; then
        second_highest_score=$highest_score
        second_category=$highest_category
        highest_score=$config_score
        highest_category="CONFIGURATION"
    elif [[ $config_score -gt $second_highest_score ]]; then
        second_highest_score=$config_score
        second_category="CONFIGURATION"
    fi
    
    # User category
    if [[ $user_score -gt $highest_score ]]; then
        second_highest_score=$highest_score
        second_category=$highest_category
        highest_score=$user_score
        highest_category="USER"
    elif [[ $user_score -gt $second_highest_score ]]; then
        second_highest_score=$user_score
        second_category="USER"
    fi
    
    # Confidence calculation
    local total_score=$((system_score + core_score + app_score + config_score + user_score))
    local confidence=0
    if [[ $total_score -gt 0 ]]; then
        confidence=$((highest_score * 100 / total_score))
    fi
    
    # Tie-breaking rules
    if [[ $highest_score -eq $second_highest_score ]] && [[ $highest_score -gt 0 ]]; then
        # Prefer more restrictive category
        local priorities=("SYSTEM" "CORE" "CONFIGURATION" "APPLICATION" "USER")
        for cat in "${priorities[@]}"; do
            if [[ "$highest_category" == "$cat" ]] || [[ "$second_category" == "$cat" ]]; then
                highest_category="$cat"
                break
            fi
        done
    fi
    
    # Minimum threshold for classification
    if [[ $highest_score -lt 30 ]]; then
        highest_category="UNKNOWN"
        confidence=0
    fi
    
    # Add reason based on what contributed most
    local reason=""
    case "$highest_category" in
        SYSTEM)
            if [[ $system_score -ge 100 ]]; then
                reason="sip_protected_volume"
            elif [[ "$signature_signed" == "apple" ]]; then
                reason="apple_signed_system_binary"
            else
                reason="system_location"
            fi
            ;;
        CORE)
            if [[ "$bundle_type" == "framework" ]]; then
                reason="os_framework"
            elif [[ "$signature_signed" == "apple" ]]; then
                reason="apple_signed_core_component"
            else
                reason="core_location"
            fi
            ;;
        APPLICATION)
            if [[ "$bundle_type" == "app" ]]; then
                reason="gui_application_bundle"
            elif [[ "$path" =~ /usr/local/ ]]; then
                reason="command_line_utility"
            else
                reason="third_party_software"
            fi
            ;;
        CONFIGURATION)
            if [[ "$path" =~ \.plist$ ]]; then
                reason="preference_file"
            elif [[ "$path" =~ ^/etc/ ]]; then
                reason="system_configuration"
            else
                reason="settings_file"
            fi
            ;;
        USER)
            if [[ "$path" =~ ^"$HOME"/(Downloads|Documents|Desktop) ]]; then
                reason="user_personal_file"
            elif [[ "$path" =~ ^/tmp/ ]]; then
                reason="temporary_file"
            else
                reason="user_data"
            fi
            ;;
        *)
            reason="insufficient_classification_data"
            ;;
    esac
    
    echo "$highest_category:$reason|confidence:$confidence|score:$highest_score"
}

# ============================================
# SYSTEM SCANNER
# ============================================

cleanslate_system_scan() {
    local scan_path="${1:-.}"
    local scan_depth="${2:-3}"
    
    print_header "ğŸ” CLEAN SLATE - SYSTEM SCANNER & FACTORY RESET PREPARATION"
    
    cleanslate_log "INFO" "Starting system scan for factory reset: $scan_path (depth: $scan_depth)"
    
    # Initialize scan report
    local scan_id=$(date +%Y%m%d_%H%M%S)
    local scan_report="${CLEANSLATE_REPORTS}/scan_${scan_id}.json"
    
    echo "{" > "$scan_report"
    echo "  \"scan_id\": \"$scan_id\"," >> "$scan_report"
    echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> "$scan_report"
    echo "  \"scan_path\": \"$scan_path\"," >> "$scan_report"
    echo "  \"scan_depth\": $scan_depth," >> "$scan_report"
    echo "  \"classifications\": {" >> "$scan_report"
    echo "    \"SYSTEM\": []," >> "$scan_report"
    echo "    \"CORE\": []," >> "$scan_report"
    echo "    \"APPLICATION\": []," >> "$scan_report"
    echo "    \"CONFIGURATION\": []," >> "$scan_report"
    echo "    \"USER\": []," >> "$scan_report"
    echo "    \"UNKNOWN\": []" >> "$scan_report"
    echo "  }," >> "$scan_report"
    echo "  \"files\": [" >> "$scan_report"
    
    local file_count=0
    local last_progress=0
    
    echo ""
    echo "Scanning files..."
    
    # Find files up to specified depth
    find "$scan_path" -maxdepth "$scan_depth" -type f 2>/dev/null | while read -r file; do
        ((file_count++))
        
        # Progress indicator every 10 files
        if [[ $((file_count % 10)) -eq 0 ]]; then
            echo -ne "\rProcessed: $file_count files..."
        fi
        
        # Collect metadata
        local metadata=$(collect_file_metadata "$file")
        
        # Classify file
        local classification=$(classify_file "$file" "$metadata")
        local category=$(echo "$classification" | cut -d':' -f1)
        
        # Log to scan database
        echo "    {" >> "$scan_report"
        echo "      \"path\": \"$file\"," >> "$scan_report"
        echo "      \"category\": \"$category\"," >> "$scan_report"
        echo "      \"metadata\": $metadata" >> "$scan_report"
        echo "    }," >> "$scan_report"
    done
    
    echo -ne "\r                                    \r"
    
    # Close JSON
    echo "  ]" >> "$scan_report"
    echo "}" >> "$scan_report"
    
    cleanslate_log "SUCCESS" "Scan complete: $file_count files processed"
    cleanslate_log "INFO" "Report saved: $scan_report"
    
    echo ""
    echo "Scan complete! Would you like to view the factory reset interface?"
    if confirm_action "Show factory reset interface"; then
        cleanslate_cleanup_interface "$scan_report"
    fi
}

# ============================================
# FACTORY RESET CLEANUP INTERFACE
# ============================================

cleanslate_cleanup_interface() {
    local report="${1:-$(ls -t $CLEANSLATE_REPORTS/scan_*.json | head -1)}"
    
    if [[ ! -f "$report" ]]; then
        cleanslate_log "ERROR" "No scan report found. Please run 'cleanslate-scan' first."
        return 1
    fi
    
    clear
    print_header "ğŸ§¹ CLEAN SLATE - FACTORY RESET CONTROL PANEL"
    
    echo "ğŸ“Š SCAN REPORT SUMMARY"
    print_separator
    
    # Display category counts
    local total_files=$(grep -c '"path":' "$report" || echo "0")
    
    echo ""
    echo "Total files scanned: $total_files"
    echo ""
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚ CATEGORY        STATUS           DESCRIPTION                â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    echo "â”‚ SYSTEM          ğŸ”’ PROTECTED     Critical OS files          â”‚"
    echo "â”‚ CORE            âš ï¸  RISKY         OS components              â”‚"
    echo "â”‚ APPLICATION     âœ… REMOVABLE     User applications          â”‚"
    echo "â”‚ CONFIGURATION   âœ… REMOVABLE     Settings files             â”‚"
    echo "â”‚ USER            âœ… REMOVABLE     Personal files             â”‚"
    echo "â”‚ UNKNOWN         â“ REVIEW        Needs inspection           â”‚"
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
    
    print_separator
    echo ""
    echo "ğŸ› ï¸  CLEANUP OPTIONS"
    echo ""
    echo "  [1] ğŸ¯ View Classification Summary"
    echo "  [2] ğŸ—‘ï¸  Safe Cleanup (USER files only)"
    echo "  [3] ğŸ§¹ Deep Cleanup (USER + CONFIG)"
    echo "  [4] ğŸ“‹ Generate HTML Report"
    echo "  [5] ğŸ” Interactive File Browser"
    echo "  [6] â†©ï¸  Return to Main Menu"
    echo ""
    
    read "choice?Select an option (1-6): "
    
    case "$choice" in
        1)
            cleanslate_show_classification_summary "$report"
            ;;
        2)
            cleanslate_safe_cleanup "$report" "USER"
            ;;
        3)
            cleanslate_safe_cleanup "$report" "USER,CONFIGURATION"
            ;;
        4)
            cleanslate_generate_html_report "$report"
            ;;
        5)
            cleanslate_interactive_browser "$report"
            ;;
        6)
            return
            ;;
        *)
            cleanslate_log "ERROR" "Invalid option"
            sleep 2
            cleanslate_cleanup_interface "$report"
            ;;
    esac
}

# ============================================
# CLASSIFICATION SUMMARY
# ============================================

cleanslate_show_classification_summary() {
    local report="$1"
    
    clear
    print_header "ğŸ“Š CLASSIFICATION SUMMARY"
    
    echo "Analyzing scan results..."
    echo ""
    
    # Count files by category
    local system_count=$(grep -c '"category": "SYSTEM"' "$report" || echo "0")
    local core_count=$(grep -c '"category": "CORE"' "$report" || echo "0")
    local app_count=$(grep -c '"category": "APPLICATION"' "$report" || echo "0")
    local config_count=$(grep -c '"category": "CONFIGURATION"' "$report" || echo "0")
    local user_count=$(grep -c '"category": "USER"' "$report" || echo "0")
    local unknown_count=$(grep -c '"category": "UNKNOWN"' "$report" || echo "0")
    
    echo "ğŸ“ˆ FILE DISTRIBUTION BY CATEGORY"
    print_separator
    echo ""
    printf "%-20s %10s %15s\n" "CATEGORY" "COUNT" "STATUS"
    print_separator
    printf "%-20s %10s %15s\n" "SYSTEM" "$system_count" "ğŸ”’ Protected"
    printf "%-20s %10s %15s\n" "CORE" "$core_count" "âš ï¸  Risky"
    printf "%-20s %10s %15s\n" "APPLICATION" "$app_count" "âœ… Removable"
    printf "%-20s %10s %15s\n" "CONFIGURATION" "$config_count" "âœ… Removable"
    printf "%-20s %10s %15s\n" "USER" "$user_count" "âœ… Removable"
    printf "%-20s %10s %15s\n" "UNKNOWN" "$unknown_count" "â“ Review"
    echo ""
    
    local removable_count=$((app_count + config_count + user_count))
    echo "ğŸ’¾ Potentially removable files: $removable_count"
    echo ""
    
    pause
    cleanslate_cleanup_interface "$report"
}

# ============================================
# SAFE FACTORY RESET ENGINE
# ============================================

cleanslate_safe_cleanup() {
    local report="$1"
    local categories="$2"
    
    clear
    print_header "ğŸ—‘ï¸  FACTORY RESET - $categories"
    
    cleanslate_log "INFO" "Starting factory reset cleanup for categories: $categories"
    
    # Create trash directory
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local trash_dir="${CLEANSLATE_TRASH}/cleanup_${timestamp}"
    mkdir -p "$trash_dir"
    
    echo ""
    echo "âš ï¸  SAFETY NOTICE"
    echo "Files will be moved to: $trash_dir"
    echo "You can restore them manually if needed."
    echo ""
    
    if ! confirm_action "Proceed with factory reset cleanup"; then
        cleanslate_log "INFO" "Factory reset cancelled by user"
        return
    fi
    
    local moved_count=0
    local failed_count=0
    
    # Process files
    IFS=',' read -A cat_array <<< "$categories"
    for category in "${cat_array[@]}"; do
        echo ""
        echo "Processing $category files..."
        
        # Extract files for this category
        grep "\"category\": \"$category\"" "$report" -B 1 | grep '"path":' | cut -d'"' -f4 | while read -r file_path; do
            if [[ -e "$file_path" ]]; then
                # Create safe name for trash
                local safe_name=$(echo "$file_path" | sed 's/^\///' | tr '/' '_')
                local trash_path="$trash_dir/$safe_name"
                
                # Move to trash
                if mv "$file_path" "$trash_path" 2>/dev/null; then
                    ((moved_count++))
                    echo "  âœ“ Moved: $(basename "$file_path")"
                else
                    ((failed_count++))
                    echo "  âœ— Failed: $(basename "$file_path")"
                fi
            fi
        done
    done
    
    echo ""
    print_separator
    cleanslate_log "SUCCESS" "Factory reset complete: $moved_count files moved, $failed_count failed"
    echo ""
    echo "Files moved to: $trash_dir"
    echo ""
    
    pause
    cleanslate_cleanup_interface "$report"
}

# ============================================
# HTML REPORT GENERATOR
# ============================================

cleanslate_generate_html_report() {
    local report="$1"
    local html_report="${report%.json}.html"
    
    cleanslate_log "INFO" "Generating HTML report..."
    
    cat > "$html_report" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean Slate Factory Reset Report</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #0d1117;
            color: #c9d1d9;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            background: linear-gradient(135deg, #1f6feb 0%, #0d1117 100%);
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: #161b22;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #30363d;
        }
        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #58a6ff;
        }
        .stat-card .number {
            font-size: 2em;
            font-weight: bold;
        }
        .category {
            background: #161b22;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #30363d;
        }
        .category.system { border-left-color: #f85149; }
        .category.core { border-left-color: #d29922; }
        .category.application { border-left-color: #58a6ff; }
        .category.configuration { border-left-color: #a371f7; }
        .category.user { border-left-color: #3fb950; }
        .category.unknown { border-left-color: #8b949e; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ§¹ Clean Slate Factory Reset Report</h1>
            <p>Generated: $(date)</p>
        </header>
        
        <div class="stats">
            <div class="stat-card">
                <h3>Total Files</h3>
                <div class="number">$(grep -c '"path":' "$report")</div>
            </div>
            <div class="stat-card">
                <h3>System Files</h3>
                <div class="number">$(grep -c '"category": "SYSTEM"' "$report")</div>
            </div>
            <div class="stat-card">
                <h3>Applications</h3>
                <div class="number">$(grep -c '"category": "APPLICATION"' "$report")</div>
            </div>
            <div class="stat-card">
                <h3>User Files</h3>
                <div class="number">$(grep -c '"category": "USER"' "$report")</div>
            </div>
        </div>
        
        <h2>Classification Summary</h2>
        <div class="category system">
            <h3>ğŸ”’ SYSTEM FILES</h3>
            <p>Critical operating system files - NEVER remove</p>
        </div>
        <div class="category core">
            <h3>âš ï¸ CORE FILES</h3>
            <p>OS components - Remove only if certain</p>
        </div>
        <div class="category application">
            <h3>âœ… APPLICATION FILES</h3>
            <p>User-installed applications - Safe to remove</p>
        </div>
        <div class="category configuration">
            <h3>âœ… CONFIGURATION FILES</h3>
            <p>Settings and preferences - Safe to remove</p>
        </div>
        <div class="category user">
            <h3>âœ… USER FILES</h3>
            <p>Personal data files - Safe to remove</p>
        </div>
        <div class="category unknown">
            <h3>â“ UNKNOWN FILES</h3>
            <p>Unclassified - Requires review</p>
        </div>
    </div>
</body>
</html>
EOF
    
    cleanslate_log "SUCCESS" "HTML report generated: $html_report"
    
    # Open in browser
    if command -v open &> /dev/null; then
        open "$html_report"
    fi
    
    pause
    cleanslate_cleanup_interface "$report"
}

# ============================================
# SYSTEM HEALTH CHECK
# ============================================

cleanslate_system_health() {
    clear
    print_header "ğŸ¥ SYSTEM HEALTH CHECK"
    
    echo "Running comprehensive system health check..."
    echo ""
    
    # Disk space
    echo "ğŸ’¾ DISK SPACE"
    print_separator
    df -h / | tail -1
    echo ""
    
    # Memory
    echo "ğŸ§  MEMORY USAGE"
    print_separator
    vm_stat | head -6
    echo ""
    
    # CPU
    echo "âš¡ CPU LOAD"
    print_separator
    uptime
    echo ""
    
    # Clean Slate status
    echo "ğŸ§¹ CLEAN SLATE STATUS"
    print_separator
    echo "Installation: ${CLEANSLATE_HOME}"
    echo "Log files: $(ls -1 "$CLEANSLATE_LOGS" 2>/dev/null | wc -l | tr -d ' ')"
    echo "Scan reports: $(ls -1 "$CLEANSLATE_REPORTS" 2>/dev/null | wc -l | tr -d ' ')"
    echo "Trash items: $(ls -1 "$CLEANSLATE_TRASH" 2>/dev/null | wc -l | tr -d ' ')"
    echo ""
    
    pause
}

# ============================================
# BACKUP SYSTEM
# ============================================

cleanslate_create_backup() {
    clear
    print_header "ğŸ’¾ SYSTEM BACKUP BEFORE RESET"
    
    local backup_dir="${CLEANSLATE_HOME}/backups"
    mkdir -p "$backup_dir"
    
    local backup_file="${backup_dir}/backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    
    cleanslate_log "INFO" "Creating system backup before factory reset..."
    
    echo "Backing up:"
    echo "  â€¢ Clean Slate configuration"
    echo "  â€¢ Scan reports"
    echo "  â€¢ User preferences"
    echo ""
    
    # Create backup
    tar -czf "$backup_file" \
        -C "$HOME" \
        ".zshrc" \
        ".zshrc_custom" \
        ".cleanslate" \
        2>/dev/null
    
    if [[ $? -eq 0 ]]; then
        local backup_size=$(du -h "$backup_file" | cut -f1)
        cleanslate_log "SUCCESS" "Backup created: $backup_file ($backup_size)"
    else
        cleanslate_log "ERROR" "Backup failed"
    fi
    
    echo ""
    pause
}

# ============================================
# MAIN MENU
# ============================================

cleanslate_system_menu() {
    clear
    print_header "ğŸ§¹ CLEAN SLATE - FACTORY RESET CONTROL CENTER"
    
    echo "Select a factory reset operation:"
    echo ""
    echo "  [1] ğŸ” Scan System for Reset"
    echo "  [2] ğŸ§¹ Factory Reset Interface"
    echo "  [3] ğŸ¥ System Health Check"
    echo "  [4] ğŸ’¾ Create Backup Before Reset"
    echo "  [5] ğŸ“Š View Reset Reports"
    echo "  [6] âš™ï¸  Settings"
    echo "  [7] â“ Help"
    echo "  [8] ğŸšª Exit"
    echo ""
    
    read "choice?Enter your choice (1-8): "
    
    case "$choice" in
        1)
            echo ""
            read "scan_path?Enter path to scan (or press Enter for current directory): "
            cleanslate_system_scan "${scan_path:-.}" 3
            ;;
        2)
            cleanslate_cleanup_interface
            ;;
        3)
            cleanslate_system_health
            cleanslate_system_menu
            ;;
        4)
            cleanslate_create_backup
            cleanslate_system_menu
            ;;
        5)
            echo ""
            echo "Available reset reports:"
            ls -1t "$CLEANSLATE_REPORTS"/*.json 2>/dev/null | head -10
            pause
            cleanslate_system_menu
            ;;
        6)
            echo ""
            cleanslate_log "INFO" "Settings interface coming soon..."
            pause
            cleanslate_system_menu
            ;;
        7)
            echo ""
            echo "Clean Slate Initialization Help"
            echo "================================"
            echo ""
            echo "Commands:"
            echo "  cleanslate        - Open main menu"
            echo "  cleanslate-scan   - Scan system for reset"
            echo "  cleanslate-reset  - Factory reset interface"
            echo "  cleanslate-health - System health check"
            echo "  cleanslate-backup - Create backup"
            echo ""
            pause
            cleanslate_system_menu
            ;;
        8)
            cleanslate_log "INFO" "Exiting Clean Slate"
            return
            ;;
        *)
            cleanslate_log "ERROR" "Invalid choice"
            sleep 1
            cleanslate_system_menu
            ;;
    esac
}

# ============================================
# INITIALIZATION
# ============================================

# Log system initialization
cleanslate_log "INFO" "Clean Slate Initialization configuration loaded"

# ============================================
# END OF .zshrc_custom
# ============================================
